<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Luau/Lua Editor + LSP (WebSocket)</title>
  <style>
    html, body, #app { height: 100%; margin: 0; background: #1e1e1e; color: #ddd; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial; }
    #toolbar { display: flex; gap: .5rem; align-items: center; padding: .5rem .75rem; background: #2b2b2b; border-bottom: 1px solid #3a3a3a; }
    #toolbar input, #toolbar button, #toolbar select { background: #1b1b1b; color: #ddd; border: 1px solid #444; border-radius: 6px; padding: .35rem .5rem; }
    #status { margin-left: auto; font-size: .875rem; opacity: .85; }
    #editor { height: calc(100% - 46px); }
    #log { position: fixed; right: 10px; bottom: 10px; width: 340px; max-height: 40vh; overflow: auto; background: #121212; border: 1px solid #333; border-radius: 10px; padding: .5rem; box-shadow: 0 10px 40px rgba(0,0,0,.5); }
    #log h3 { margin: 0 0 .5rem 0; font-size: .9rem; font-weight: 600; }
    #log pre { font-size: .75rem; white-space: pre-wrap; word-break: break-word; }
    .ok { color: #a6e3a1; }
    .warn { color: #f9e2af; }
    .err { color: #f38ba8; }
  </style>
  <!-- Monaco via CDN (user should host locally for production) -->
  <script>window.require = { paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' } };</script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/editor/editor.main.nls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/editor/editor.main.js"></script>
</head>
<body>
  <div id="app">
    <div id="toolbar">
      <label for="endpoint">LSP:</label>
      <input id="endpoint" size="36" aria-label="LSP WebSocket URL" />
      <select id="language">
        <option value="luau" selected>luau</option>
        <option value="lua">lua</option>
      </select>
      <button id="connectBtn">Po≈ÇƒÖcz</button>
      <button id="disconnectBtn" disabled>Roz≈ÇƒÖcz</button>
      <button id="formatBtn" title="Format document">Formatuj</button>
      <span id="status">‚è≥ Niepo≈ÇƒÖczony</span>
    </div>
    <div id="editor"></div>
  </div>

  <div id="log" aria-live="polite" aria-atomic="true">
    <h3>Log LSP</h3>
    <pre id="logBody"></pre>
  </div>

  <script type="module">
    import { createLspClient } from './src/lspClient.js';
    import { attachMonaco } from './src/monacoGlue.js';

    // Basic app wiring
    const log = (msg, level='info') => {
      const el = document.getElementById('logBody');
      const cls = level === 'error' ? 'err' : level === 'warn' ? 'warn' : 'ok';
      el.textContent = '[' + new Date().toLocaleTimeString() + '] ' + msg + '\n' + el.textContent;
    };

    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const formatBtn = document.getElementById('formatBtn');
    const endpointInput = document.getElementById('endpoint');
    const languageSelect = document.getElementById('language');

    // Derive default endpoint smartly based on origin
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const host = location.hostname || 'localhost';
    const defPort = proto === 'wss' ? (location.port || '443') : (location.port || '8080');
    endpointInput.value = `${proto}://${host}:${defPort}/lsp`;

    // Initialize Monaco
    let editorModelUri = monaco.Uri.parse('file:///virtual/Main.client.luau');
    let editor = monaco.editor.create(document.getElementById('editor'), {
      value: `-- Luau demo\nlocal Players = game:GetService('Players')\nprint('Hello Luau!', Players.LocalPlayer)\n`,
      language: 'lua', // Monaco doesn't have 'luau' by default, we map below
      theme: 'vs-dark',
      automaticLayout: true,
      minimap: { enabled: true },
      tabSize: 2
    });
    editor.setModel(monaco.editor.createModel(editor.getValue(), 'lua', editorModelUri));

    // Pretend 'luau' as 'lua' for Monaco tokenization, but keep languageId for LSP
    let languageId = 'luau';

    let lsp;
    let detachMonaco = null;
    let version = 1;

    const setStatus = (text) => { statusEl.textContent = text; };

    function computeTextDocumentItem() {
      const model = editor.getModel();
      return {
        uri: model.uri.toString(true),
        languageId,
        version,
        text: model.getValue()
      };
    }

    // Hook up Monaco providers to LSP once connected
    function wireMonaco(lspClient) {
      if (detachMonaco) detachMonacco?.(); // guard old
      detachMonaco = attachMonaco({ monaco, editor, lsp: lspClient, languageId, getDocument: computeTextDocumentItem, log });
    }

    // Connect button
    connectBtn.addEventListener('click', async () => {
      const url = endpointInput.value.trim();
      languageId = languageSelect.value || 'luau';
      try {
        setStatus('üîå ≈ÅƒÖczenie‚Ä¶');
        lsp = createLspClient({ url, languageId, log, onStatus: setStatus });
        await lsp.connect();

        // Initialize session
        const td = computeTextDocumentItem();
        await lsp.initialize({
          processId: null,
          rootUri: null,
          capabilities: lsp.clientCapabilities(),
          workspaceFolders: null
        });
        await lsp.initialized();
        log('LSP initialized', 'info');

        // Open the document
        await lsp.didOpen(td);
        wireMonaco(lsp);

        // Send changes
        editor.onDidChangeModelContent((e) => {
          version++;
          if (lsp.serverSyncKind === 2 /* Incremental */) {
            const changes = e.changes.map(ch => ({
              range: {
                start: { line: ch.range.startLineNumber - 1, character: ch.range.startColumn - 1 },
                end: { line: ch.range.endLineNumber - 1, character: ch.range.endColumn - 1 }
              },
              rangeLength: ch.rangeLength,
              text: ch.text
            }));
            lsp.didChange({
              textDocument: { uri: editor.getModel().uri.toString(true), version },
              contentChanges: changes
            });
          } else {
            lsp.didChange({
              textDocument: { uri: editor.getModel().uri.toString(true), version },
              contentChanges: [{ text: editor.getValue() }]
            });
          }
        });

        setStatus('‚úÖ Po≈ÇƒÖczony');
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
      } catch (e) {
        console.error(e);
        log('B≈ÇƒÖd po≈ÇƒÖczenia: ' + (e?.message || e), 'error');
        setStatus('‚ùå B≈ÇƒÖd po≈ÇƒÖczenia');
      }
    });

    // Disconnect
    disconnectBtn.addEventListener('click', async () => {
      try {
        await lsp?.shutdown();
        await lsp?.disconnect();
      } catch {}
      setStatus('‚è≥ Niepo≈ÇƒÖczony');
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
    });

    // Format document
    formatBtn.addEventListener('click', async () => {
      if (!lsp) return;
      try {
        const edits = await lsp.formatting({
          textDocument: { uri: editor.getModel().uri.toString(true) },
          options: { tabSize: editor.getOption(monaco.editor.EditorOption.tabSize), insertSpaces: true }
        });
        if (Array.isArray(edits) && edits.length) {
          // Apply edits (simple implementation, apply from end)
          const model = editor.getModel();
          const monacoEdits = edits.map(e => ({
            range: new monaco.Range(
              e.range.start.line + 1, e.range.start.character + 1,
              e.range.end.line + 1, e.range.end.character + 1
            ),
            text: e.newText
          }));
          model.pushEditOperations([], monacoEdits, () => null);
          log('Sformatowano dokument', 'info');
        } else {
          log('Brak zmian formatujƒÖcych', 'warn');
        }
      } catch (e) {
        log('Formatowanie nieudane: ' + e.message, 'error');
      }
    });

    // Save on Cmd/Ctrl+S: send didSave
    window.addEventListener('keydown', (ev) => {
      if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 's') {
        ev.preventDefault();
        const uri = editor.getModel().uri.toString(true);
        lsp?.didSave({ textDocument: { uri } });
        log('Zapisano (didSave)', 'info');
      }
    });
  </script>
</body>
</html>
